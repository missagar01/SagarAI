// --- CONFIGURATION ---
const ALLOWED_SHEETS = [
  "LEAD",
  "ENQUIRY",
  "STORE",
  "O2D"
];

// Regex for INT (BIGINT)
const INT_REGEX = /^[-+]?\d+$/;
// Regex for FLOAT (FLOAT8) - handles "123.45", "123.", ".45"
const FLOAT_REGEX = /^[-+]?(\d*\.\d+|\d+\.\d*)$/;
// Regex for ISO Timestamps
const TIMESTAMP_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})?$/;
// Regex for common Date formats (YYYY-MM-DD or MM/DD/YYYY or DD/MM/YYYY)
const COMMON_DATE_REGEX = /^((\d{4}-\d{1,2}-\d{1,2})|(\d{1,2}\/\d{1,2}\/\d{4}))$/;

/**
 * Adds a custom menu to the Google Sheet UI when the spreadsheet is opened.
 */
function onOpen() {
  SpreadsheetApp.getUi()
      .createMenu('Supabase Sync')
      .addItem('‚ñ∂Ô∏è Run Full Sync For All Sheets', 'runDatabaseSync')
      .addToUi();
}

/**
 * Helper function to fetch and format data from allowed sheets.
 * This logic is shared by doGet() and runDatabaseSync().
 */
function getSheetData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const out = {};

  ss.getSheets().forEach(sheet => {
    const name = sheet.getName();
    if (ALLOWED_SHEETS.indexOf(name) === -1) return; // skip

    const data = sheet.getDataRange().getValues();
    if (!data || data.length < 2) {
      console.log(`Skipping sheet "${name}": No data or headers only.`);
      return; // skip if empty or headers only
    }

    const headers = data.shift().map(h => String(h)); // Get headers
    
    const rows = data.map(row => {
      const obj = {};
      headers.forEach((h, i) => {
        if (h) { // Only add if header is not empty
          obj[h] = row[i];
        }
      });
      return obj;
    });

    out[name] = rows;
  });
  return out;
}


/**
 * Main function to sync all sheet data to the Supabase database.
 */
function runDatabaseSync() {
  const SCRIPT_PROPS = PropertiesService.getScriptProperties();
  const SUPABASE_URL = SCRIPT_PROPS.getProperty("SUPABASE_URL");
  const SUPABASE_KEY = SCRIPT_PROPS.getProperty("SUPABASE_SERVICE_KEY");

  if (!SUPABASE_URL || !SUPABASE_KEY) {
    console.error("‚ùå Missing SUPABASE_URL or SUPABASE_SERVICE_KEY in Script Properties.");
    return;
  }
  
  console.log("üöÄ Starting database sync...");
  
  const sheetsData = getSheetData();
  const tableNames = Object.keys(sheetsData);
  
  if (tableNames.length === 0) {
    console.log("‚ÑπÔ∏è No sheet data found to sync.");
    return;
  }
  
  console.log(`Found ${tableNames.length} sheet(s) to process: ${tableNames.join(', ')}`);

  // --- Loop through each sheet ---
  for (const tableName of tableNames) {
    const rows = sheetsData[tableName];
    
    // Sanitize table name
    const sanitizedTableName = tableName.replace(/[^a-zA-Z0-9_]/g, '_');
    console.log(`\n--- Processing table: ${sanitizedTableName} ---`);
    
    if (!rows || rows.length === 0) {
      console.log("- Skipping empty sheet.");
      continue;
    }

    // Sanitize row keys
    const sanitizedRows = rows.map(row => {
      const newRow = {};
      for (const key in row) {
        if (key) { 
          const sanitizedKey = key.replace(/[^a-zA-Z0-9_]/g, '_');
          newRow[sanitizedKey] = row[key];
        }
      }
      return newRow;
    });

    // 1. Get Column Definitions
    const columnDefinitions = getColumnTypes(sanitizedRows);
    console.log("- Column types inferred:", JSON.stringify(columnDefinitions));
    
    // 2. Create SQL command
    const colsSql = Object.keys(columnDefinitions)
      .map(col => `"${col}" ${columnDefinitions[col]}`)
      .join(', ');
      
    const createTableSql = `CREATE TABLE "${sanitizedTableName}" (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, ${colsSql});`;
    
    // 3. Execute DROP and CREATE TABLE
    console.log(`- Calling RPC to reset table "${sanitizedTableName}"...`);
    const rpcParams = {
      table_name: sanitizedTableName,
      create_sql: createTableSql
    };
    const setupSuccess = callSupabaseRpc('setup_table_from_sync', rpcParams, SUPABASE_URL, SUPABASE_KEY);

    if (!setupSuccess) {
      console.error(`- Halting sync for "${sanitizedTableName}" due to schema error.`);
      continue;
    }

    // 4. --- NEW: PREPARE AND INSERT DATA ---
    console.log(`- Normalizing ${sanitizedRows.length} rows for insertion...`);
    
    const cleanRows = sanitizedRows.map(row => {
      const cleanRow = {};
      for (const key in row) {
        if (columnDefinitions.hasOwnProperty(key)) {
          const sql_type = columnDefinitions[key];
          cleanRow[key] = normalizeValue(row[key], sql_type);
        }
      }
      return cleanRow;
    });

    // 5. --- NEW: INSERT ROWS ---
    if (cleanRows.length > 0) {
      console.log(`- Inserting ${cleanRows.length} rows...`);
      insertSupabaseRows(sanitizedTableName, cleanRows, SUPABASE_URL, SUPABASE_KEY);
    } else {
      console.log("- No rows to insert.");
    }
  }
  
  console.log("\nüéâ Full sync process complete!");
}

/**
 * Determines the type level for a single value, checking native types first.
 * 0=BIGINT, 1=FLOAT8, 2=DATE, 3=TIMESTAMP, 4=TEXT
 */
function getValueTypeLevel(value) {
  if (value === null || value === undefined) return -1;

  // 1. Check for NATIVE types from Google Sheets
  if (typeof value === 'number') {
    return Number.isInteger(value) ? 0 : 1; // 0=BIGINT, 1=FLOAT8
  }
  if (value instanceof Date) {
    // Check if it has time components (ignores timezone)
    if (value.getHours() > 0 || value.getMinutes() > 0 || value.getSeconds() > 0) {
      return 3; // 3=TIMESTAMP
    }
    return 2; // 2=DATE
  }

  // 2. It's not a native type, so treat it as a STRING
  const s = String(value).trim();
  if (s === "") return -1;

  // 0: BIGINT
  if (INT_REGEX.test(s)) return 0;
  // 1: FLOAT8
  if (FLOAT_REGEX.test(s)) return 1;

  // 3: TIMESTAMP (check first, as it's more specific)
  // Check for ISO strings, or strings with time
  if (TIMESTAMP_REGEX.test(s) || s.includes(':')) {
    // Final check: can it be parsed as a valid date?
    if (!isNaN(new Date(s).getTime())) {
      return 3;
    }
  }
  
  // 2: DATE
  // Check for simple dates
  if (COMMON_DATE_REGEX.test(s)) {
     if (!isNaN(new Date(s).getTime())) {
      return 2;
    }
  }

  // 4: TEXT
  return 4;
}

/**
 * Scans rows and determines final SQL type per column, just like the Python script.
 */
function getColumnTypes(rows) {
  if (!rows || rows.length === 0) return {};
  
  const headers = Object.keys(rows[0]);
  const typeHierarchy = ["BIGINT", "FLOAT8", "DATE", "TIMESTAMP", "TEXT"];
  let columnLevels = {};
  headers.forEach(h => columnLevels[h] = -1);

  for (const row of rows) {
    for (const colName in row) {
      if (!columnLevels.hasOwnProperty(colName)) continue;

      const value = row[colName];
      const valueLevel = getValueTypeLevel(value);

      if (valueLevel === -1) continue; // Skip null/empty

      const currentLevel = columnLevels[colName];
      if (currentLevel === -1) {
        columnLevels[colName] = valueLevel;
        continue;
      }

      if (currentLevel === 4) continue; // Already TEXT
      if (valueLevel === 4) {
        columnLevels[colName] = 4; // Promote to TEXT
        continue;
      }

      // Check for mixed numeric/date types
      const isCurrentNumeric = currentLevel <= 1;
      const isValueNumeric = valueLevel <= 1;
      const isCurrentDateTime = currentLevel >= 2;
      const isValueDateTime = valueLevel >= 2;

      if ((isCurrentNumeric && isValueDateTime) || (isCurrentDateTime && isValueNumeric)) {
        columnLevels[colName] = 4; // Mixed types, promote to TEXT
      } else {
        columnLevels[colName] = Math.max(currentLevel, valueLevel);
      }
    }
  }

  let finalTypes = {};
  for (const h in columnLevels) {
    const level = columnLevels[h];
    finalTypes[h] = (level === -1) ? "TEXT" : typeHierarchy[level];
  }
  return finalTypes;
}


/**
 * Normalizes a single value for insertion into Supabase.
 * - Converts JS Date objects to ISO strings.
 * - Handles null/empty values.
 * - Attempts to parse date/time strings if they aren't objects yet.
 */
function normalizeValue(value, sql_type) {
  if (value === null || value === undefined || value === "") {
    return null;
  }

  // If it's a date/time column
  if (sql_type === "DATE" || sql_type === "TIMESTAMP") {
    let dt;
    
    // Check if it's already a JS Date object (common from Sheets)
    if (value instanceof Date) {
      dt = value;
    } else {
      // If it's a string, try to parse it
      const parsed = new Date(value);
      if (!isNaN(parsed.getTime())) {
        dt = parsed;
      }
    }

    if (dt) {
      // Format as full ISO string for Supabase
      return dt.toISOString();
    }
  }
  
  // For all other types (TEXT, BIGINT, FLOAT8) or unparseable dates,
  // return the value as-is. Supabase client handles type coercion.
  return value;
}

/**
 * Inserts rows into a Supabase table using the REST API.
 */
function insertSupabaseRows(tableName, rows, supabaseUrl, serviceKey) {
  const insertUrl = `${supabaseUrl}/rest/v1/${tableName}`;

  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      'apikey': serviceKey,
      'Authorization': `Bearer ${serviceKey}`,
      'Prefer': 'resolution=merge-duplicates' // This is the "upsert" part
    },
    payload: JSON.stringify(rows),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(insertUrl, options);
    const responseCode = response.getResponseCode();
    const responseBody = response.getContentText();

    // 201 Created is the success code for insert
    if (responseCode === 201) {
      console.log(`‚úÖ Inserted ${rows.length} rows into "${tableName}".`);
      return true;
    } else {
      console.error(`‚ùå Insert failed for "${tableName}". Code: ${responseCode}. Error: ${responseBody}`);
      return false;
    }
  } catch (e) {
    console.error(`‚ùå Exception during insert for "${tableName}": ${e}`);
    return false;
  }
}


/**
 * Calls a Supabase RPC (Remote Procedure Call) function.
 * @param {string} functionName The name of the SQL function in Supabase.
 * @param {Object} params The parameters to pass to the function.
 * @param {string} supabaseUrl Your project's SUPABASE_URL.
 * @param {string} serviceKey Your project's SUPABASE_SERVICE_KEY.
 */
function callSupabaseRpc(functionName, params, supabaseUrl, serviceKey) {
  const rpcUrl = `${supabaseUrl}/rest/v1/rpc/${functionName}`;
  
  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      'apikey': serviceKey,
      'Authorization': `Bearer ${serviceKey}`,
      'Prefer': 'wait=5' // Wait 5 seconds for function to complete
    },
    payload: JSON.stringify(params),
    muteHttpExceptions: true // So we can read the error message if one occurs
  };

  try {
    const response = UrlFetchApp.fetch(rpcUrl, options);
    const responseCode = response.getResponseCode();
    const responseBody = response.getContentText();

    if (responseCode === 200) {
      console.log(`‚úÖ RPC "${functionName}" successful. Response: ${responseBody}`);
      return true;
    } else {
      console.error(`‚ùå RPC "${functionName}" failed. Code: ${responseCode}. Error: ${responseBody}`);
      return false;
    }
  } catch (e) {
    console.error(`‚ùå Exception calling RPC "${functionName}": ${e}`);
    return false;
  }
}